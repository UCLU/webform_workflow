<?php
/**
 * @file
 * A simple workflow module for webforms.
 */

define('WEBFORM_WORKFLOW_ORIGINAL_AUTHOR', -1);

/**
 * Implements hook_entity_info().
 */
function webform_workflow_entity_info() {
  $entities = array();

  $entities['webform_workflow_state'] = array(
    'label' => t('Webform Workflow State'),
    'controller class' => 'WebformWorkflowStateController',
    'views controller class' => 'EntityDefaultViewsController',
    'uri callback' => 'webform_workflow_state_uri',
    'access callback' => 'webform_workflow_state_access',
    'base table' => 'webform_workflow_states',
    'revision table' => 'commerce_event_ticket_revision',
    'token type' => 'commerce-event-ticket',
    'entity keys' => array(
      'id' => 'wsid',
      'label' => 'label'
    ),
    'view callback' => 'entity_metadata_view_single',
    'static cache' => TRUE,
    'fieldable' => TRUE,
    'module' => 'webform_workflow',
    'metatag' => FALSE,
    'redirect' => FALSE,
    'inline entity form' => array(
      'controller' => 'WebformWorkflowStateInlineEntityFormController',
    ),
  );

  return $entities;
}

/**
 * Access callback for a workflow state.
 */
function webform_workflow_state_access($op, $state, $account = NULL) {
  $node = node_load($state->nid);
  return node_access('update', $node);
}

/**
 * URI callback for a workflow state.
 */
function webform_workflow_state_uri($state) {
  return 'node/' . $state->nid . '/webform/workflow/state/' . $state->wsid;
}

/**
 * Load a single workflow state.
 */
function webform_workflow_state_load($wsid) {
  $states = entity_load('webform_workflow_state', array($wsid));
  return $states ? reset($states) : FALSE;
}

/**
 * Implements hook_menu().
 */
function webform_workflow_menu() {
  $items['node/%webform_menu/webform/workflow'] = array(
    'title' => 'Workflow',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_workflow_config_form', 1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'includes/webform_workflow.forms.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['node/%webform_menu/webform/workflow/state/%webform_workflow_state'] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('webform_workflow_state', 5),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_workflow_state_form', 1, 5),
    'file' => 'includes/webform_workflow_state.forms.inc',
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
  );

  $items['node/%webform_menu/submission/%webform_menu_submission/state/%/confirmation'] = array(
    'title' => 'Workflow State Change - Add message',
    'page callback' => 'webform_workflow_confirmation',
    'page arguments' => array(1, 3, 5),
    'access callback' => 'webform_submission_access',
    'access arguments' => array(1, 3, 'edit'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function webform_workflow_theme($existing, $type, $theme, $path) {
  return array(
    'webform_workflow_admin_form' => array(
      'render element' => 'element',
      'file' => 'includes/webform_workflow.theme.inc',
    ),
  );
}

/**
 * For webform API see: http://drupalcontrib.org/api/drupal/contributions%21webform%21webform.api.php/7
 */

/**
 * Get form entry text from array of user uids or emails.
 */
function webform_workflow_get_user_text($notify_users) {
  $users = array();
  foreach ($notify_users as $u) {
    if (is_numeric($u)) {
      $user = user_load($u);
      $users[] = $user->name;
    }
    else {
      $users[] = $u;
    }
  }
  return implode("\n", $users);
}

/**
 * Implements hook_webform_submission_render_alter().
 *
 * Alter the display of a webform.
 */
function webform_workflow_webform_submission_render_alter(&$renderable) {
  $node = $renderable['#node'];
  if (webform_workflow_is_enabled($node)) {
    $submission = $renderable['#submission'];
    $state = $submission->webform_workflow_state;
    $renderable['workflow'] = array(
      '#type' => 'fieldset',
      '#title' => 'Workflow',
      '#weight' => -1,
    );

    $label = $state->label ? $state->label : t('Unknown');

    $renderable['workflow']['state'] = array(
      '#markup' => "Current state: " . $label,
    );
    $renderable['workflow']['log'] = array(
      '#type' => 'fieldset',
      '#title' => 'Transition Log',
    );

    $items = array();
    foreach (webform_workflow_log_get($submission->sid) as $log) {
      $user = user_load($log->uid);
      $user_name = ($user) ? $user->name : "Unknown user";
      $message = ($log->message) ? $log->message . '.' : '';
      $from_state = webform_workflow_state_load($log->wsid_from);
      $from_label = ($from_state) ? $from_state['label'] : 'Unknown';
      $to_state = webform_workflow_state_load($log->wsid_to);
      $to_label = ($to_state) ? $to_state['label'] : 'Unknown';
      $timestamp = $log->timestamp;
      $date = DateTime::createFromFormat('U', $timestamp);

      $items[] = t("@date Transition from <strong>@from</strong> to <strong>@to</strong> by @user. @message", array(
        '@date' => $date->format('d/m/Y H:i'),
        '@from' => $from_label,
        '@to' => $to_label,
        '@user' => $user_name,
        '@message' => $message,
      ));
    }

    $renderable['workflow']['log']['items'] = array(
      '#markup' => theme('item_list', array('items' => $items)),
    );
  }
}

/**
 * Implements hook_webform_submission_load().
 *
 * Respond to the loading of Webform submissions.
 */
function webform_workflow_webform_submission_load(&$submissions) {
  foreach ($submissions as $sid => $submission) {
    $node = node_load($submission->nid);
    if (webform_workflow_is_enabled($node)) {
      $wsid = webform_workflow_get_submission_state($sid);
      $state = $wsid ? webform_workflow_state_load($wsid) : entity_create('webform_workflow_state', array(
        'nid' => $node->nid,
      ));
      $submission->webform_workflow_state = $state;
    }
  }
}

/**
 * Implements hook_webform_submission_actions().
 */
function webform_workflow_webform_submission_actions($node, $submission) {
  $actions = array();

  if (webform_workflow_is_enabled($node) && webform_submission_access($node, $submission, 'edit')) {
    global $user;
    $transition_from_current = FALSE;

    /*
     * Get the current workflow state of the node, and workout
     * whether the user can transition FROM this state. If they can't
     * we don't output any links at all.
     */
    $current_state = $submission->webform_workflow_state;

    foreach ($user->roles as $rid => $role) {
      if (in_array($rid, $current_state->data['permissions']['from'])) {
        $transition_from_current = TRUE;
        break;
      }
    }

    if ($transition_from_current) {

      /*
       * User can transition from the current workflow state so now
       * we have to get all the states this user has permission to transition TO.
       */

      $available_states = webform_workflow_get_available_states($node);

      foreach ($available_states as $state) {
        if (in_array($rid, $state->data['permissions']['to'])) {

          // only output a link if we're not in that state already - we can't transition to the same state we're already in!
          if ($current_state['wsid'] != $state->wsid) {
            $action = 'workflow_' . strtolower($state->label);
            $actions[$action] = array(
              'title' => $state->label,
              'href' => 'node/' . $node->nid . '/submission/' . $submission->sid . '/state/' . $state->wsid . '/confirmation',
            );
          }

        }
      }
    }
  };

  return $actions;
}

/**
 * State change confirmation page form - allows user to add
 * comments on the transition
 */
function webform_workflow_confirmation($node, $submission, $next_state_id) {

  $output = '';

  $form = drupal_get_form('webform_workflow_confirmation_form', $node, $submission, $next_state_id);
  $output .= render($form);

  return $output;

}

/**
 * State change confirmation page form - allows user to add
 * comments on the transition
 */
function webform_workflow_confirmation_form($form, &$form_state, $node, $submission, $next_state_id) {

  $form['message'] = array(
    '#type' => 'textarea',
    '#title' => t('Comment on this state change'),
    '#required' => TRUE,
  );


  $form['submit'] = array(
    '#type' => 'submit',
    '#title' => t('Comment on this state change'),
    '#value' => t('Make this change'),
  );

  return $form;

}

function webform_workflow_confirmation_form_submit($form, &$form_state){

  if ($form_state['build_info']['args']
    && isset($form_state['build_info']['args'][0])
    && isset($form_state['build_info']['args'][1])
    && isset($form_state['build_info']['args'][2])) {

    $node = $form_state['build_info']['args'][0];
    $submission = $form_state['build_info']['args'][1];
    $next_state_id = $form_state['build_info']['args'][2];

    $message = $form_state['values']['message'];

    webform_workflow_transition($node, $submission, $next_state_id, $message);

  }
  else {
    drupal_set_message(t('Unable to make transition'), 'error');
    watchdog('webform_workflow', t('Failed to make workflow state transition: missing confirmation form arguments'), WATCHDOG_ERROR);
  }

}

/**
 * Move the Submission into the next workflow state callback
 *
 * Transition the workflow on to the next state if possible.
 */
function webform_workflow_transition($node, $submission, $next_state_id, $message = NULL) {

  $next_state = webform_workflow_state_load($next_state_id);

  if ($next_state) {
    $current_state = $submission->webform_workflow_state;

    // check to make sure we're not trying to move to the same state as the current one
    if ($current_state['wsid'] != $next_state_id) {
      $current_label = $current_state['label'];
      $next_label = $next_state['label'];
      $submission->webform_workflow_state = $next_state;
      webform_submission_update($node, $submission);
      webform_workflow_log_transition($submission, $current_state, $next_state, $message);
      drupal_set_message(t("Transitioned submission from @current_state to @next_state",
        array('@current_state' => $current_label, '@next_state' => $next_label)));

      webform_workflow_notify_users($submission);

      if (module_exists('rules')) {
        rules_invoke_event('webform_workflow_transition', $node, $current_state, $next_state);
      }
    }
    else {
      drupal_set_message(t("Submission is already in the @state state.", array('@state' => $current_state['label'])), "error");
    }

  }

  drupal_goto("node/{$node->nid}/submission/{$submission->sid}");
}

/**
 * Log the transition to a log table.
 */
function webform_workflow_log_transition($submission, $from, $to, $message = NULL) {
  global $user;

  $record = array(
    'nid' => $submission->nid,
    'sid' => $submission->sid,
    'uid' => $user->uid,
    'wsid_from' => $from['wsid'],
    'wsid_to' => $to['wsid'],
    'message' => $message,
    'timestamp' => REQUEST_TIME,
  );

  drupal_write_record('webform_workflow_log', $record);
}


/**
 * Get the transitions from the log table.
 */
function webform_workflow_log_get($sid) {
  $query = db_select('webform_workflow_log', 'wwl')
    ->fields('wwl')
    ->condition('sid', $sid)
    ->execute();

  if ($result = $query->fetchAllAssoc('id')) {
    return $result;
  }

  return array();
}

/**
 * Implements hook_webform_submission_insert().
 *
 * Insert a submission record for webform and state.
 */
function webform_workflow_webform_submission_insert($node, $submission) {
  if (webform_workflow_is_enabled($node)) {
    $state = webform_workflow_get_next_state($submission);
    $record = array(
      'nid' => $node->nid,
      'sid' => $submission->sid,
      'wsid' => $state['wsid'],
    );

    drupal_write_record('webform_workflow_submissions', $record);
  }
}

/**
 * Implements hook_webform_submission_update().
 *
 * Update the webform submission record.
 */
function webform_workflow_webform_submission_update($node, $submission) {
  if (webform_workflow_is_enabled($node) && $submission->webform_workflow_state) {
    webform_workflow_write_submission_state($submission);
  }
}

/**
 * Implements hook_webform_submission_delete().
 *
 * Delete the submission record.
 */
function webform_workflow_webform_submission_delete($node, $submission) {
  // delete all submission data, even if workflow is no longer enabled
  webform_workflow_delete_submission_state($submission->sid);

  db_delete('webform_workflow_log')
    ->condition('sid', $submission->sid)
    ->execute();
}

/**
 * Get the next workflow state.
 */
function webform_workflow_get_next_state($submission, $reversed = FALSE) {
  $node = node_load($submission->nid);
  $states = webform_workflow_get_available_states($node);
  if ($reversed) {
    $states = array_reverse($states, TRUE);
  }
  if (!isset($submission->webform_workflow_state)) {
    return reset($states);
  }
  else {
    $wsid = $submission->webform_workflow_state['wsid'];
    // Don't even think about using array_shift in a foreach loop!
    // http://us3.php.net/manual/en/function.array-shift.php:
    // "All numerical array keys will be modified to start counting from zero..."
    do {
      $state = array_shift($states);
    } while ($state && $state['wsid'] != $wsid);
  }

  return array_shift($states);
}

/**
 * Implements hook_webform_submission_access().
 *
 * Put our access check into the webform.
 */
function webform_workflow_webform_submission_access($node, $submission, $op, $account) {
  if (webform_workflow_is_enabled($node)) {
    if (!isset($submission->webform_workflow_state)) {
      return FALSE;
    }
    $state = $submission->webform_workflow_state;
    if (empty($state->data['permissions'][$op])) {
      return FALSE;
    }

    $roles = array_keys($account->roles);

    // If we are the original author, add to our role list to flag this.
    if ($submission->uid == $account->uid) {
      $roles[] = WEBFORM_WORKFLOW_ORIGINAL_AUTHOR;
    }

    foreach ($roles as $rid) {
      if (in_array($rid, $state[$op . '_permissions'])) {
        return TRUE;
      }
    }
    return FALSE;
  }

}

/**
 * Implements hook_node_load().
 */
function webform_workflow_node_load($nodes, $types) {
  $webform_types = webform_node_types();
  if (count(array_intersect($types, $webform_types)) == 0) {
    return;
  }

  // Load workflow data.
  $result = db_select('webform_workflow', 'ww')
    ->fields('ww', array('nid', 'workflow', 'data'))
    ->condition('nid', array_keys($nodes), 'IN')
    ->execute()
    ->fetchAllAssoc('nid', PDO::FETCH_OBJ);

  foreach ($result as $nid => $workflow) {
    if (empty($workflow->data)) {
      $workflow->data = array();
    }
    else {
      $workflow->data = unserialize($workflow->data);
    }
    if (empty($workflow->data['emails'])) {
      $workflow->data['emails'] = webform_workflow_get_default_email();
    }
    $nodes[$nid]->webform_workflow = $workflow;
  }
}

/**
 * Get default email content for a workflow state change notification.
 *
 * @return array
 *   An array containing the keys 'subject' and 'body'.
 */
function webform_workflow_get_default_email() {
  return array(
    'subject' => t('The form [node:title] has changed state'),
    'body' => "Webform: [node:title]\n[submission:url]",
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function webform_workflow_form_node_form_alter(&$form, &$form_state) {
  unset($form['field_ww_states']);
}

/**
 * Check if workflow has been enabled for the current webform.
 *
 * @param object $node
 *
 * @return bool
 */
function webform_workflow_is_enabled($node) {
  return !empty($node->webform_workflow);
}

/**
 * Get all states attached to a webform.
 *
 * @param int $nid
 *   The node id of the webform.
 *
 * @return array
 *   An array of states.
 */
function webform_workflow_get_available_states($node) {
  $states = array();
  $wrapper = entity_metadata_wrapper('node', $node);
  if (empty($wrapper->ww_states)) {
    return array();
  }
  foreach ($wrapper->ww_states as $key => $state_wrapper) {
    $states[$key] = $state_wrapper->value();
  }
  return $states;
}

/**
 * Sort states by weight.
 */
function _webform_workflow_state_sort($a, $b) {
  if ($a->weight != $b->weight) {
    return $a->weight < $b->weight ? -1 : 1;
  }
  elseif ($a->name == $b->name) {
    return 0;
  }
  return $a->name < $b->name ? -1 : 1;
}

/**
 * Ajax callback for the add another state button.
 */
function webform_workflow_add_more_callback($form, $form_state) {
  return $form['states'];
}

/**
 * Submission callback for the add another state button.
 */
function webform_workflow_add_another_submit($form, &$form_state) {
  $form_state['num_states']++;
  $form_state['rebuild'] = TRUE;
}

/**
 * Get the currently assigned workflow state to a submission.
 */
function webform_workflow_get_submission_state($sid) {
  $query = db_select('webform_workflow_submissions', 'wws')
    ->fields('wws', array())
    ->condition('wws.sid', $sid)
    ->execute();

  if ($result = $query->fetch()) {
    return $result->wsid;
  }

  return NULL;
}

/**
 * Delete a submission state from the database.
 *
 * @param int $sid
 *   The workflow state id to delete.
 */
function webform_workflow_delete_submission_state($sid) {
  return db_delete('webform_workflow_submissions')
    ->condition('sid', $sid)
    ->execute();
}

/**
 * Write submission state to the database.
 *
 * @param object $submission
 *   The webform submissions.
 */
function webform_workflow_write_submission_state($submission) {
  db_merge('webform_workflow_submissions')
    ->key(array('sid' => $submission->sid))
    ->fields(array(
      'nid' => $submission->nid,
      'wsid' => $submission->webform_workflow_state['wsid'],
    ))
    ->execute();
}

/**
 * Delete a state from the database.
 *
 * @param int $wsid
 *   The workflow state id to delete.
 */
function webform_workflow_state_delete($wsid) {
  return entity_get_controller('webform_workflow_state')->delete(array($wsid));
}

/**
 * Notify users of state transition by email.
 */
function webform_workflow_notify_users($submission) {
  $notify_emails = webform_workflow_get_user_emails($submission->webform_workflow_state['notify_users']);

  global $user;
  $email_from = $user->mail;

  $nid = $submission->nid;
  $email_templates = webform_workflow_load($nid)->data['emails'];

  $token_data = array(
    // @TODO: Add workflow tokens once complete.
    'node' => node_load($nid),
    'webform-submission' => $submission,
  );
  $params = array(
    'subject' => token_replace($email_templates['subject'], $token_data),
    'body'    => token_replace($email_templates['body'   ], $token_data),
  );

  foreach ($notify_emails as $email) {
    drupal_mail('webform_workflow', 'transition', $email, LANGUAGE_NONE, $params, $email_from);
  }
}

/**
 * Implements hook_mail().
 */
function webform_workflow_mail($key, &$message, $params) {
  switch($key) {
    case 'transition':
      $message['subject'] = $params['subject'];
      $message['body'][] = $params['body'];
      break;
  }
}
