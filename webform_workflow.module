<?php
/**
 * @file
 * A simple workflow module for webforms.
 */

define('WEBFORM_WORKFLOW_ORIGINAL_SUBMITTER', 'WWOS');

/**
 * Implements hook_entity_info().
 */
function webform_workflow_entity_info() {
  $entities = array();

  $entities['webform_workflow_state'] = array(
    'label' => t('Webform Workflow State'),
    'controller class' => 'WebformWorkflowStateController',
    'views controller class' => 'EntityDefaultViewsController',
    'uri callback' => 'webform_workflow_state_uri',
    'access callback' => 'webform_workflow_state_access',
    'base table' => 'webform_workflow_states',
    'entity keys' => array(
      'id' => 'wsid',
      'label' => 'label'
    ),
    'view callback' => 'entity_metadata_view_single',
    'static cache' => TRUE,
    'fieldable' => TRUE,
    'module' => 'webform_workflow',
    'metatag' => FALSE,
    'redirect' => FALSE,
    'inline entity form' => array(
      'controller' => 'WebformWorkflowStateInlineEntityFormController',
    ),
  );

  // Expose webform submissions as very basic entities just so that Views Bulk
  // Operations can be used.
  $entities['webform_workflow_submission'] = array(
    'label' => t('Webform Submission'),
    'controller class' => 'EntityAPIController',
    'base table' => 'webform_submissions',
    'entity keys' => array(
      'id' => 'sid',
      'label' => 'sid',
    ),
    'module' => 'webform_workflow',
  );

  return $entities;
}

/**
 * Access callback for a workflow state.
 *
 * @param string $op
 *   The operation to perform. Usually 'view', 'create', 'update'. Unused.
 * @param object $state
 *   The state object.
 * @param object $account
 *   The user account.
 *
 * @return bool
 */
function webform_workflow_state_access($op, $state, $account = NULL) {
  if ($op == 'delete' && webform_workflow_state_is_locked($state)) {
    return FALSE;
  }
  $node = $state->nid ? node_load($state->nid) : menu_get_object('webform_menu');
  // Account for Inline Entity Form's AJAX callbacks, which mean that the node
  // ID is not available in the URL (when checking for create access, the
  // $state passed in will not have a node ID).
  if (!$node
    && $op == 'create'
    && !empty($_POST)
    && $_POST['form_id'] == 'webform_workflow_config_form'
    && drupal_valid_token($_POST['form_token'], $_POST['form_id'])) {
    return TRUE;
  }
  return $node && node_access('update', $node, $account);
}

/**
 * Check whether a state is locked against deletion.
 *
 * @return bool
 *   TRUE if the state has any submissions associated with it, FALSE otherwise.
 */
function webform_workflow_state_is_locked($state) {
  $query = db_select('webform_workflow_submissions')
    ->condition('wsid', $state->wsid)
    ->range(0, 1);
  $query->addExpression('COUNT(*)');
  $count = $query->execute()->fetchField();
  return $count > 0;
}

/**
 * Entity URI callback for a workflow state.
 *
 * @param object $state
 *   The workflow state entity object.
 *
 * @return array
 *   An array containing a path in the key 'path'.
 */
function webform_workflow_state_uri($state) {
  return array(
    'path' => 'node/' . $state->nid . '/webform/workflow/state/' . $state->wsid,
  );
}

/**
 * Load a single workflow state.
 *
 * @param int $wsid
 *   The workflow state ID.
 *
 * @return object|FALSE
 *   A workflow state entity object, or FALSE if the $wsid was not found.
 */
function webform_workflow_state_load($wsid) {
  $states = entity_load('webform_workflow_state', array($wsid));
  return $states ? reset($states) : FALSE;
}

/**
 * Implements hook_menu().
 */
function webform_workflow_menu() {
  $items['node/%webform_menu/webform/workflow'] = array(
    'title' => 'Workflow',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_workflow_config_form', 1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'includes/webform_workflow.forms.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 4,
  );

  $items['node/%webform_menu/webform/workflow/state/%webform_workflow_state'] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('webform_workflow_state', 5),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_workflow_state_form', 1, 5),
    'file' => 'includes/webform_workflow_state.forms.inc',
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
  );

  $items['node/%webform_menu/submission/%webform_menu_submission/workflow-log'] = array(
    'title' => 'Workflow Log',
    'page callback' => 'webform_workflow_log_page',
    'page arguments' => array(1, 3),
    'file' => 'includes/webform_workflow.pages.inc',
    'access callback' => 'webform_workflow_log_access',
    'access arguments' => array(1, 3),
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function webform_workflow_menu_alter(&$items) {
  $items['node/%webform_menu/webform-results']['page callback'] = 'webform_workflow_submissions_list';
  $items['node/%webform_menu/webform-results']['page arguments'] = array(1);
  $items['node/%webform_menu/webform-results']['file'] = 'includes/webform_workflow.pages.inc';
  $items['node/%webform_menu/webform-results']['module'] = 'webform_workflow';
}

/**
 * Implements hook_webform_submission_render_alter().
 *
 * Alter the display of a webform submission.
 */
function webform_workflow_webform_submission_render_alter(&$renderable) {
  $node = $renderable['#node'];
  $submission = $renderable['#submission'];
  if (!webform_workflow_is_enabled($node) || $submission->is_draft || !webform_results_access($node)) {
    return;
  }

  $state = $submission->webform_workflow_state;
  module_load_include('inc', 'webform_workflow', 'includes/webform_workflow.forms');
  $renderable['workflow'] = drupal_get_form('webform_workflow_submission_state_form', $submission);
  $renderable['workflow']['#weight'] = -1;
}

/**
 * Access callback for viewing the Workflow Log tab on a node or submission.
 */
function webform_workflow_log_access($node, $submission = NULL, $account = NULL) {
  return webform_workflow_is_enabled($node)
    && webform_results_access($node)
    && !$submission->is_draft
    && webform_submission_access($node, $submission, 'view');
}

/**
 * For webform API see: http://drupalcontrib.org/api/drupal/contributions%21webform%21webform.api.php/7
 */

/**
 * Get form entry text from array of user uids or emails.
 */
function webform_workflow_get_user_text($notify_users) {
  $users = array();
  foreach ($notify_users as $u) {
    if (is_numeric($u)) {
      $user = user_load($u);
      $users[] = $user->name;
    }
    else {
      $users[] = $u;
    }
  }
  return implode("\n", $users);
}

/**
 * Implements hook_webform_submission_load().
 *
 * Respond to the loading of Webform submissions.
 */
function webform_workflow_webform_submission_load(&$submissions) {
  // Find the workflow state IDs associated with these submissions.
  $wsids = db_select('webform_workflow_submissions', 'wws')
    ->fields('wws', array('sid', 'wsid'))
    ->condition('wws.sid', array_keys($submissions), 'IN')
    ->execute()
    ->fetchAllKeyed();
  $unknown_state = entity_create('webform_workflow_state', array(
    'label' => t('None'),
  ));
  $states = $wsids ? entity_load('webform_workflow_state', $wsids) : array();
  foreach ($submissions as $sid => $submission) {
    $node = node_load($submission->nid);
    if (!webform_workflow_is_enabled($node)) {
      continue;
    }
    if (isset($wsids[$sid]) && isset($states[$wsids[$sid]])) {
      $submission->webform_workflow_state = $states[$wsids[$sid]];
    }
    else {
      $submission->webform_workflow_state = clone $unknown_state;
      $submission->webform_workflow_state->nid = $submission->nid;
    }
  }
}

/**
 * Change the state of a submission.
 *
 * @param object $submission
 * @param object $new_state
 * @param string $message
 */
function webform_workflow_transition($submission, $new_state, $message = NULL) {

  $current_state = $submission->webform_workflow_state;

  if ($submission->is_draft) {
    drupal_set_message(t('Submission @sid is a draft, so it cannot have a workflow state.', array(
      '@sid' => $submission->sid,
    )), 'warning');
  }
  elseif ($current_state->wsid != $new_state->wsid) {
    $current_label = $current_state->label;
    $new_label = $new_state->label;
    $submission->webform_workflow_state = $new_state;
    webform_workflow_write_submission_state($submission);
    webform_workflow_log_transition($submission, $current_state, $new_state, $message);
    drupal_set_message(t("Transitioned submission @sid from %current_state to %new_state.", array(
      '@sid' => $submission->sid,
      '%current_state' => $current_label,
      '%new_state' => $new_label,
    )));

    webform_workflow_notify_users($submission);

    if (module_exists('rules')) {
      $node = node_load($submission->nid);
      rules_invoke_event('webform_workflow_transition', $node, $current_state, $new_state);
    }
  }
  else {
    drupal_set_message(t('Submission @sid is already in the state %state.', array(
      '@sid' => $submission->sid,
      '%state' => $new_state->label,
    )), 'warning');
  }

}

/**
 * Log the transition to a log table.
 *
 * @param object $submission
 *   The submission.
 * @param object $from
 *   The old state.
 * @param object $to
 *   The new state.
 * @param string $message
 *   A log message.
 */
function webform_workflow_log_transition($submission, $from, $to, $message = NULL) {
  global $user;

  $record = array(
    'nid' => $submission->nid,
    'sid' => $submission->sid,
    'uid' => $user->uid,
    'old_state_wsid' => $from->wsid,
    'new_state_wsid' => $to->wsid,
    'message' => $message,
    'timestamp' => REQUEST_TIME,
  );

  drupal_write_record('webform_workflow_log', $record);
}

/**
 * Implements hook_webform_submission_insert().
 */
function webform_workflow_webform_submission_insert($node, $submission) {
  // Set new (non-draft) submissions to the default state.
  if (webform_workflow_is_enabled($node) && !$submission->is_draft && !isset($submission->webform_workflow_state)) {
    $state = webform_workflow_state_get_default($node);
    if (!$state) {
      return;
    }
    $record = array(
      'nid' => $node->nid,
      'sid' => $submission->sid,
      'wsid' => $state->wsid,
    );
    drupal_write_record('webform_workflow_submissions', $record);
  }
}

/**
 * Implements hook_webform_submission_update().
 *
 * Update the webform submission record.
 */
function webform_workflow_webform_submission_update($node, $submission) {
  if (webform_workflow_is_enabled($node) && isset($submission->webform_workflow_state)) {
    webform_workflow_write_submission_state($submission);
  }
}

/**
 * Implements hook_webform_submission_delete().
 *
 * Act after a submission has been deleted.
 */
function webform_workflow_webform_submission_delete($node, $submission) {
  // Delete all data related to the submission, even if workflow is no longer
  // enabled.
  db_delete('webform_workflow_submissions')
    ->condition('sid', $sid)
    ->execute();
  db_delete('webform_workflow_log')
    ->condition('sid', $submission->sid)
    ->execute();
}

/**
 * Get the default workflow state for a node.
 */
function webform_workflow_state_get_default($node) {
  $states = webform_workflow_get_available_states($node);
  return $states ? reset($states) : FALSE;
}

/**
 * Implements hook_entity_delete().
 */
function webform_workflow_entity_delete($entity, $type) {
  // When a state is deleted, update its entries in our other tables.
  if ($type === 'webform_workflow_state') {
    db_delete('webform_workflow_submissions')
      ->condition('wsid', $entity->wsid)
      ->execute();
    db_update('webform_workflow_log')
      ->fields(array('new_state_wsid' => NULL))
      ->condition('new_state_wsid', $entity->wsid)
      ->execute();
    db_update('webform_workflow_log')
      ->fields(array('old_state_wsid' => NULL))
      ->condition('old_state_wsid', $entity->wsid)
      ->execute();
  }
  // When a webform_workflow_submission entity is deleted, make sure its related
  // submission is deleted properly.
  elseif ($type === 'webform_workflow_submission') {
    $node = node_load($entity->nid);
    module_load_include('inc', 'webform', 'includes/webform.submissions');
    $submission = webform_get_submission($entity->nid, $entity->sid);
    if ($submission) {
      webform_submission_delete($node, $submission);
    }
  }
}

/**
 * Implements hook_webform_submission_access().
 *
 * Put our access check into the webform.
 */
function webform_workflow_webform_submission_access($node, $submission, $op, $account) {
  if (webform_workflow_is_enabled($node) && $submission && isset($submission->webform_workflow_state)) {
    $state = $submission->webform_workflow_state;
    if (empty($state->data['permissions'][$op])) {
      return FALSE;
    }

    $roles = array_keys($account->roles);

    // If we are the original author, add to our role list to flag this.
    if ($submission->uid == $account->uid) {
      $roles[] = WEBFORM_WORKFLOW_ORIGINAL_SUBMITTER;
    }

    foreach ($roles as $rid) {
      if (in_array($rid, $state->data['permissions'][$op])) {
        return TRUE;
      }
    }
    return FALSE;
  }
}

/**
 * Implements hook_node_load().
 */
function webform_workflow_node_load($nodes, $types) {
  $webform_types = webform_node_types();
  if (count(array_intersect($types, $webform_types)) == 0) {
    return;
  }

  // Load workflow data.
  $result = db_select('webform_workflow', 'ww')
    ->fields('ww', array('nid', 'workflow', 'data'))
    ->condition('nid', array_keys($nodes), 'IN')
    ->execute()
    ->fetchAllAssoc('nid', PDO::FETCH_OBJ);

  foreach ($result as $nid => $workflow) {
    if (empty($workflow->data)) {
      $workflow->data = array();
    }
    else {
      $workflow->data = unserialize($workflow->data);
    }
    if (empty($workflow->data['emails'])) {
      $workflow->data['emails'] = webform_workflow_get_default_email();
    }
    $nodes[$nid]->webform_workflow = $workflow;
  }
}

/**
 * Get default email content for a workflow state change notification.
 *
 * @return array
 *   An array containing the keys 'subject' and 'body'.
 */
function webform_workflow_get_default_email() {
  return array(
    'subject' => t('The form [node:title] has changed state'),
    'body' => "Webform: [node:title]\n[submission:url]",
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function webform_workflow_form_node_form_alter(&$form, &$form_state) {
  unset($form['webform_workflow_states']);
}

/**
 * Check if workflow has been enabled for the current webform.
 *
 * @param object $node
 *
 * @return bool
 */
function webform_workflow_is_enabled($node) {
  return isset($node->webform_workflow) && $node->webform_workflow->workflow;
}

/**
 * Get all states attached to a webform.
 *
 * @param int $nid
 *   The node id of the webform.
 *
 * @return array
 *   An array of states.
 */
function webform_workflow_get_available_states($node) {
  $states = array();
  $wrapper = entity_metadata_wrapper('node', $node);
  if (empty($wrapper->webform_workflow_states)) {
    return array();
  }
  foreach ($wrapper->webform_workflow_states as $key => $state_wrapper) {
    $states[$key] = $state_wrapper->value();
  }
  return $states;
}

/**
 * Write submission state to the database.
 *
 * @param object $submission
 *   The webform submission.
 */
function webform_workflow_write_submission_state($submission) {
  if (isset($submission->webform_workflow_state) && !empty($submission->webform_workflow_state->wsid)) {
    db_merge('webform_workflow_submissions')
      ->key(array('sid' => $submission->sid))
      ->fields(array(
        'nid' => $submission->nid,
        'wsid' => $submission->webform_workflow_state->wsid,
      ))
      ->execute();
  }
}

/**
 * Delete a state from the database.
 *
 * @param int $wsid
 *   The workflow state id to delete.
 */
function webform_workflow_state_delete($wsid) {
  return entity_get_controller('webform_workflow_state')->delete(array($wsid));
}

/**
 * Notify users of state transition by email.
 */
function webform_workflow_notify_users($submission) {
  $state = $submission->webform_workflow_state;
  $notify_emails = webform_workflow_get_user_emails($state->data['notify_users']);

  if (!$notify_emails) {
    return;
  }

  global $user;
  $email_from = $user->mail;

  $node = node_load($submission->nid);
  $email_templates = webform_workflow_load($node)->data['emails'];

  $token_data = array(
    // @TODO: Add workflow tokens once complete.
    'node' => $node,
    'webform-submission' => $submission,
  );
  $params = array(
    'subject' => token_replace($email_templates['subject'], $token_data),
    'body'    => token_replace($email_templates['body'   ], $token_data),
  );

  foreach ($notify_emails as $email) {
    drupal_mail('webform_workflow', 'transition', $email, LANGUAGE_NONE, $params, $email_from);
  }
}

/**
 * Get array of emails from array of user uids or emails.
 */
function webform_workflow_get_user_emails($notify_users) {
  $emails = array();
  foreach ($notify_users as $u) {
    if (is_numeric($u)) {
      $user = user_load($u);
      $emails[] = $user->mail;
    }
    elseif (valid_email_address($u)) {
      $emails[] = $u;
    }
  }
  return $emails;
}

/**
 * Implements hook_mail().
 */
function webform_workflow_mail($key, &$message, $params) {
  switch($key) {
    case 'transition':
      $message['subject'] = $params['subject'];
      $message['body'][] = $params['body'];
      break;
  }
}

/**
 * Implements hook_theme().
 */
function webform_workflow_theme() {
  return array(
    'webform_workflow_state' => array(
      'variables' => array(
        'state' => NULL,
      ),
    ),
    'webform_workflow_state_color' => array(
      'variables' => array(
        'color' => NULL,
        'html' => FALSE,
        'content' => NULL,
        'classes_array' => array(),
      ),
    ),
  );
}

/**
 * Theme a webform workflow state.
 */
function theme_webform_workflow_state($variables) {
  return theme('webform_workflow_state_color', array(
    'content' => $variables['state']->label,
    'color' => $variables['state']->color,
    'classes_array' => array('webform-workflow-state'),
  ));
}

/**
 * Simple theme function to add color to some text.
 */
function theme_webform_workflow_state_color($variables) {
  $content = $variables['content'];
  if (empty($variables['html'])) {
    $content = check_plain($content);
  }
  $attributes = array('class' => array(
    'webform-workflow-state-label',
  ));
  $color_suffix = $variables['color'] ? $variables['color'] : 'none';
  $attributes['class'][] = drupal_html_class('webform-workflow-state-color-' . $color_suffix);
  $attributes['class'] = array_merge($variables['classes_array'], $attributes['class']);
  return '<span' . drupal_attributes($attributes) . '>' . $content . '</span>';
}

/**
 * Implements hook_views_api().
 */
function webform_workflow_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'webform_workflow') . '/includes',
  );
}

/**
 * Implements hook_action_info().
 */
function webform_workflow_action_info() {
  return array(
    'webform_workflow_change_submission_state' => array(
      'type' => 'webform_workflow_submission',
      'label' => t('Change workflow state'),
      'configurable' => TRUE,
    ),
  );
}

/**
 * Action configuration form for changing the workflow state of a submission.
 *
 * @see webform_workflow_action_info()
 */
function webform_workflow_change_submission_state_form($context) {
  $node = menu_get_object('webform_menu');
  if (!$node || !webform_workflow_is_enabled($node)) {
    drupal_set_message(t('Webform or workflow settings not found'), 'error', FALSE);
    return array();
  }
  $states = webform_workflow_get_available_states($node);
  if (!$states) {
    drupal_set_message(t('No states found'), 'warning', FALSE);
    return array();
  }
  global $user;
  $is_admin = node_access('update', $node, $user);
  $state_options = array();
  $state_colors = array();
  foreach ($states as $state) {
    if (array_intersect(array_keys($user->roles), $state->data['permissions']['to'])
      || $is_admin) {
      $state_options[$state->wsid] = $state->label;
      if ($state->color) {
        $state_colors['state-' . $state->wsid] = $state->color;
      }
    }
  }
  if (!$state_options) {
    drupal_set_message(t('No available states found'), 'warning', FALSE);
    return array();
  }
  $form['new_state'] = array(
    '#type' => 'select',
    '#title' => t('New state'),
    '#options' => $state_options,
    '#required' => TRUE,
  );
  if ($state_colors) {
    $form['new_state']['#attributes']['class'] = array('webform-workflow-state-select');
    $form['new_state']['#attached']['js'] = array(
      drupal_get_path('module', 'webform_workflow') . '/includes/webform_workflow.js',
      array(
        'data' => array('webformWorkflow' => array('stateColors' => $state_colors)),
        'type' => 'setting',
      ),
    );
  }
  $form['message'] = array(
    '#type' => 'textfield',
    '#title' => t('Log message'),
    '#description' => t('Describe why you are making this change.'),
    '#required' => !empty($node->webform_workflow->data['require_log']),
  );
  return $form;
}

/**
 * Submit callback for the 'Change workflow state' action configuration form.
 *
 * @see webform_workflow_action_info()
 */
function webform_workflow_change_submission_state_submit($form, &$form_state) {
  return array(
    'new_state' => webform_workflow_state_load($form_state['values']['new_state']),
    'message' => $form_state['values']['message'] ? $form_state['values']['message'] : NULL,
  );
}

/**
 * Action callback for changing the workflow state of a submission.
 *
 * @param object $submission
 *   The submission, loaded via the Entity API as a
 *   'webform_workflow_submission' entity.
 * @param array $context
 *   Contextual information provided by the action configuration form. This must
 *   include the keys 'new_state' and 'message'.
 *
 * @see webform_workflow_action_info()
 */
function webform_workflow_change_submission_state($submission, $context) {
  // Reload the submission as a proper Webform submission object.
  module_load_include('inc', 'webform', 'includes/webform.submissions');
  $submission = webform_get_submission($submission->nid, $submission->sid);

  $node = node_load($submission->nid);
  $is_admin = node_access('update', $node);

  $current_state = $submission->webform_workflow_state;
  $transition_from_current = $is_admin || array_intersect(array_keys($user->roles), $current_state->data['permissions']['from']);
  if (!$transition_from_current) {
    return;
  }

  webform_workflow_transition($submission, $context['new_state'], $context['message']);
}

/**
 * Implements hook_webform_results_download_submission_information_info().
 */
function webform_workflow_webform_results_download_submission_information_info() {
  return array('state' => t('Workflow State'));
}

/**
 * Implements hook_webform_results_download_submission_information_data().
 */
function webform_workflow_webform_results_download_submission_information_data($token, $submission, array $options, $serial_start, $row_count) {
  if ($token == 'state') {
    $node = node_load($submission->nid);
    if (webform_workflow_is_enabled($node)) {
      return $submission->webform_workflow_state->label;
    }
  }
}

/**
 * Get a list of possible state colors.
 *
 * @return array
 */
function webform_workflow_state_color_options_list() {
  return array(
    '' => t('None'),
    'green' => t('Green'),
    'amber' => t('Amber'),
    'red' => t('Red'),
    'blue' => t('Blue'),
    'purple' => t('Purple'),
    'yellow' => t('Yellow'),
  );
}
