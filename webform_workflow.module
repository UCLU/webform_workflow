<?php
/**
 * @file
 * A simple workflow module for webforms.
 */

define('WEBFORM_WORKFLOW_ORIGINAL_SUBMITTER', 'WWOS');

/**
 * Implements hook_entity_info().
 */
function webform_workflow_entity_info() {
  $entities = array();

  $entities['webform_workflow_state'] = array(
    'label' => t('Webform Workflow State'),
    'controller class' => 'WebformWorkflowStateController',
    'views controller class' => 'EntityDefaultViewsController',
    'uri callback' => 'webform_workflow_state_uri',
    'access callback' => 'webform_workflow_state_access',
    'base table' => 'webform_workflow_states',
    'entity keys' => array(
      'id' => 'wsid',
      'label' => 'label'
    ),
    'view callback' => 'entity_metadata_view_single',
    'static cache' => TRUE,
    'fieldable' => TRUE,
    'module' => 'webform_workflow',
    'metatag' => FALSE,
    'redirect' => FALSE,
    'inline entity form' => array(
      'controller' => 'WebformWorkflowStateInlineEntityFormController',
    ),
  );

  return $entities;
}

/**
 * Access callback for a workflow state.
 *
 * @param string $op
 *   The operation to perform. Usually 'view', 'create', 'update'. Unused.
 * @param object $state
 *   The state object.
 * @param object $account
 *   The user account.
 *
 * @return bool
 */
function webform_workflow_state_access($op, $state, $account = NULL) {
  if ($op == 'delete' && webform_workflow_state_is_locked($state)) {
    return FALSE;
  }
  $node = $state->nid ? node_load($state->nid) : menu_get_object('webform_menu');
  // Account for Inline Entity Form's AJAX callbacks, which mean that the node
  // ID is not available in the URL (when checking for create access, the
  // $state passed in will not have a node ID).
  if (!$node
    && $op == 'create'
    && !empty($_POST)
    && $_POST['form_id'] == 'webform_workflow_config_form'
    && drupal_valid_token($_POST['form_token'], $_POST['form_id'])) {
    return TRUE;
  }
  return $node && node_access('update', $node, $account);
}

/**
 * Check whether a state is locked against deletion.
 *
 * @return bool
 *   TRUE if the state has any submissions associated with it, FALSE otherwise.
 */
function webform_workflow_state_is_locked($state) {
  $query = db_select('webform_workflow_submissions')
    ->condition('wsid', $state->wsid)
    ->range(0, 1);
  $query->addExpression('COUNT(*)');
  $count = $query->execute()->fetchField();
  return $count > 0;
}

/**
 * URI callback for a workflow state.
 */
function webform_workflow_state_uri($state) {
  return 'node/' . $state->nid . '/webform/workflow/state/' . $state->wsid;
}

/**
 * Load a single workflow state.
 */
function webform_workflow_state_load($wsid) {
  $states = entity_load('webform_workflow_state', array($wsid));
  return $states ? reset($states) : FALSE;
}

/**
 * Implements hook_menu().
 */
function webform_workflow_menu() {
  $items['node/%webform_menu/webform/workflow'] = array(
    'title' => 'Workflow',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_workflow_config_form', 1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'includes/webform_workflow.forms.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['node/%webform_menu/webform/workflow/state/%webform_workflow_state'] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('webform_workflow_state', 5),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_workflow_state_form', 1, 5),
    'file' => 'includes/webform_workflow_state.forms.inc',
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
  );

  $items['node/%webform_menu/submission/%webform_menu_submission/state/%/confirmation'] = array(
    'title' => 'Workflow State Change - Add message',
    'page callback' => 'webform_workflow_confirmation',
    'page arguments' => array(1, 3, 5),
    'access callback' => 'webform_submission_access',
    'access arguments' => array(1, 3, 'edit'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * For webform API see: http://drupalcontrib.org/api/drupal/contributions%21webform%21webform.api.php/7
 */

/**
 * Get form entry text from array of user uids or emails.
 */
function webform_workflow_get_user_text($notify_users) {
  $users = array();
  foreach ($notify_users as $u) {
    if (is_numeric($u)) {
      $user = user_load($u);
      $users[] = $user->name;
    }
    else {
      $users[] = $u;
    }
  }
  return implode("\n", $users);
}

/**
 * Implements hook_webform_submission_render_alter().
 *
 * Alter the display of a webform.
 */
function webform_workflow_webform_submission_render_alter(&$renderable) {
  $node = $renderable['#node'];
  if (!webform_workflow_is_enabled($node)) {
    return;
  }

  $submission = $renderable['#submission'];
  $state = $submission->webform_workflow_state;

  $renderable['workflow'] = array(
    '#type' => 'fieldset',
    '#title' => 'Workflow',
    '#weight' => -1,
  );

  $renderable['workflow']['form'] = drupal_get_form('webform_workflow_submission_state_form', $submission);
}

/**
 * Implements hook_webform_submission_load().
 *
 * Respond to the loading of Webform submissions.
 */
function webform_workflow_webform_submission_load(&$submissions) {
  foreach ($submissions as $sid => $submission) {
    $node = node_load($submission->nid);
    if (webform_workflow_is_enabled($node)) {
      $wsid = webform_workflow_get_submission_state($sid);
      $state = $wsid ? webform_workflow_state_load($wsid) : FALSE;
      $submission->webform_workflow_state = $state ? $state : entity_create('webform_workflow_state', array(
        'nid' => $node->nid,
        'label' => t('None'),
      ));
    }
  }
}

/**
 * Form for changing the state of an existing submission.
 */
function webform_workflow_submission_state_form($form, &$form_state, $submission) {
  global $user;

  $node = node_load($submission->nid);
  $is_admin = node_access('update', $node);

  $state = $submission->webform_workflow_state;
  $transition_from_current = $is_admin || array_intersect(array_keys($user->roles), $state->data['permissions']['from']);
  if (!$transition_from_current) {
    return;
  }

  $new_state_options = array();
  $seen_current = FALSE;
  $available_states = webform_workflow_get_available_states($node);
  foreach ($available_states as $new_state) {
    if ($new_state->wsid == $state->wsid) {
      $seen_current = TRUE;
      continue;
    }
    if (array_intersect(array_keys($user->roles), $new_state->data['permissions']['to'])
        || $is_admin) {
      $key = $seen_current ? t('Later states') : t('Earlier states');
      $new_state_options[$key][$new_state->wsid] = $new_state->label;
    }
  }

  $form['current_state'] = array(
    '#type' => 'item',
    '#title' => t('Current state'),
    '#markup' => check_plain($state->label),
  );

  if (!$new_state_options) {
    return $form;
  }

  $form_state['submission'] = $submission;

  $form['new_state'] = array(
    '#title' => t('New state'),
    '#type' => 'select',
    '#options' => $new_state_options,
    '#required' => TRUE,
  );
  $new_state_trigger = array(
    ':input[name="new_state"]' => array('!value' => ''),
  );
  $form['message'] = array(
    '#type' => 'textfield',
    '#title' => t('Log message'),
    '#description' => t('Optionally, describe why you are making this change.'),
    '#states' => array('visible' => $new_state_trigger),
  );
  $form['buttons'] = array(
    '#type' => 'actions',
    '#states' => array('visible' => $new_state_trigger),
  );
  $form['buttons']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Change state'),
  );

  $form['#attached']['css'][] = drupal_get_path('module', 'webform_workflow') . '/includes/webform_workflow.css';
  return $form;
}

/**
 * Submit callback for changing the state of an existing submission.
 */
function webform_workflow_submission_state_form_submit($form, &$form_state){
  $submission = $form_state['submission'];
  $node = node_load($submission->nid);
  $new_state = webform_workflow_state_load($form_state['values']['new_state']);
  $message = $form_state['values']['message'];
  webform_workflow_transition($node, $submission, $new_state, $message);
}

/**
 * Change the state of a submission.
 *
 * @param object $node
 * @param object $submission
 * @param object $new_state
 * @param string $message
 */
function webform_workflow_transition($node, $submission, $new_state, $message = NULL) {
  $current_state = $submission->webform_workflow_state;

  if ($current_state->wsid != $new_state->wsid) {
    $current_label = $current_state->label;
    $new_label = $new_state->label;
    $submission->webform_workflow_state = $new_state;
    webform_submission_update($node, $submission);
    webform_workflow_log_transition($submission, $current_state, $new_state, $message);
    drupal_set_message(t("Transitioned submission from @current_state to @new_state",
      array('@current_state' => $current_label, '@new_state' => $new_label)));

    webform_workflow_notify_users($submission);

    if (module_exists('rules')) {
      rules_invoke_event('webform_workflow_transition', $node, $current_state, $new_state);
    }
  }
  else {
    drupal_set_message(t("Submission is already in the state %state", array('%state' => $new_state->label)), "error");
  }

  drupal_goto("node/{$node->nid}/submission/{$submission->sid}");
}

/**
 * Log the transition to a log table.
 *
 * @param object $submission
 *   The submission.
 * @param object $from
 *   The old state.
 * @param object $to
 *   The new state.
 * @param string $message
 *   A log message.
 */
function webform_workflow_log_transition($submission, $from, $to, $message = NULL) {
  global $user;

  $record = array(
    'nid' => $submission->nid,
    'sid' => $submission->sid,
    'uid' => $user->uid,
    'wsid_from' => $from->wsid,
    'wsid_to' => $to->wsid,
    'wsid_from_label' => $from->label,
    'wsid_to_label' => $to->label,
    'message' => $message,
    'timestamp' => REQUEST_TIME,
  );

  drupal_write_record('webform_workflow_log', $record);
}

/**
 * Implements hook_webform_submission_insert().
 */
function webform_workflow_webform_submission_insert($node, $submission) {
  // Set new submissions to the default state.
  if (webform_workflow_is_enabled($node) && !isset($submission->webform_workflow_state)) {
    $state = webform_workflow_state_get_default($node);
    if (!$state) {
      return;
    }
    $record = array(
      'nid' => $node->nid,
      'sid' => $submission->sid,
      'wsid' => $state->wsid,
    );
    drupal_write_record('webform_workflow_submissions', $record);
  }
}

/**
 * Implements hook_webform_submission_update().
 *
 * Update the webform submission record.
 */
function webform_workflow_webform_submission_update($node, $submission) {
  if (webform_workflow_is_enabled($node) && isset($submission->webform_workflow_state)) {
    webform_workflow_write_submission_state($submission);
  }
}

/**
 * Implements hook_webform_submission_delete().
 *
 * Delete the submission record.
 */
function webform_workflow_webform_submission_delete($node, $submission) {
  // delete all submission data, even if workflow is no longer enabled
  webform_workflow_delete_submission_state($submission->sid);

  db_delete('webform_workflow_log')
    ->condition('sid', $submission->sid)
    ->execute();
}

/**
 * Get the default workflow state for a node.
 */
function webform_workflow_state_get_default($node) {
  $states = webform_workflow_get_available_states($node);
  return $states ? reset($states) : FALSE;
}

/**
 * Implements hook_entity_delete().
 */
function webform_workflow_entity_delete($entity, $type) {
  // When a state is deleted, update its entries in our other tables.
  if ($type === 'webform_workflow_state') {
    db_delete('webform_workflow_submissions')
      ->condition('wsid', $entity->wsid)
      ->execute();
    db_update('webform_workflow_log')
      ->fields(array('wsid_to' => NULL))
      ->condition('wsid_to', $entity->wsid)
      ->execute();
    db_update('webform_workflow_log')
      ->fields(array('wsid_from' => NULL))
      ->condition('wsid_from', $entity->wsid)
      ->execute();
  }
}

/**
 * Implements hook_webform_submission_access().
 *
 * Put our access check into the webform.
 */
function webform_workflow_webform_submission_access($node, $submission, $op, $account) {
  if (webform_workflow_is_enabled($node) && $submission && isset($submission->webform_workflow_state)) {
    $state = $submission->webform_workflow_state;
    if (empty($state->data['permissions'][$op])) {
      return FALSE;
    }

    $roles = array_keys($account->roles);

    // If we are the original author, add to our role list to flag this.
    if ($submission->uid == $account->uid) {
      $roles[] = WEBFORM_WORKFLOW_ORIGINAL_SUBMITTER;
    }

    foreach ($roles as $rid) {
      if (in_array($rid, $state->data['permissions'][$op])) {
        return TRUE;
      }
    }
    return FALSE;
  }
}

/**
 * Implements hook_node_load().
 */
function webform_workflow_node_load($nodes, $types) {
  $webform_types = webform_node_types();
  if (count(array_intersect($types, $webform_types)) == 0) {
    return;
  }

  // Load workflow data.
  $result = db_select('webform_workflow', 'ww')
    ->fields('ww', array('nid', 'workflow', 'data'))
    ->condition('nid', array_keys($nodes), 'IN')
    ->execute()
    ->fetchAllAssoc('nid', PDO::FETCH_OBJ);

  foreach ($result as $nid => $workflow) {
    if (empty($workflow->data)) {
      $workflow->data = array();
    }
    else {
      $workflow->data = unserialize($workflow->data);
    }
    if (empty($workflow->data['emails'])) {
      $workflow->data['emails'] = webform_workflow_get_default_email();
    }
    $nodes[$nid]->webform_workflow = $workflow;
  }
}

/**
 * Get default email content for a workflow state change notification.
 *
 * @return array
 *   An array containing the keys 'subject' and 'body'.
 */
function webform_workflow_get_default_email() {
  return array(
    'subject' => t('The form [node:title] has changed state'),
    'body' => "Webform: [node:title]\n[submission:url]",
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function webform_workflow_form_node_form_alter(&$form, &$form_state) {
  unset($form['webform_workflow_states']);
}

/**
 * Check if workflow has been enabled for the current webform.
 *
 * @param object $node
 *
 * @return bool
 */
function webform_workflow_is_enabled($node) {
  return !empty($node->webform_workflow);
}

/**
 * Get all states attached to a webform.
 *
 * @param int $nid
 *   The node id of the webform.
 *
 * @return array
 *   An array of states.
 */
function webform_workflow_get_available_states($node) {
  $states = array();
  $wrapper = entity_metadata_wrapper('node', $node);
  if (empty($wrapper->webform_workflow_states)) {
    return array();
  }
  foreach ($wrapper->webform_workflow_states as $key => $state_wrapper) {
    $states[$key] = $state_wrapper->value();
  }
  return $states;
}

/**
 * Ajax callback for the add another state button.
 */
function webform_workflow_add_more_callback($form, $form_state) {
  return $form['states'];
}

/**
 * Submission callback for the add another state button.
 */
function webform_workflow_add_another_submit($form, &$form_state) {
  $form_state['num_states']++;
  $form_state['rebuild'] = TRUE;
}

/**
 * Get the currently assigned workflow state to a submission.
 *
 * @return mixed
 *   The state ID (wsid), or FALSE if there is no state assigned.
 */
function webform_workflow_get_submission_state($sid) {
  return db_select('webform_workflow_submissions', 'wws')
    ->fields('wws', array('wsid'))
    ->condition('wws.sid', $sid)
    ->execute()
    ->fetchField();
}

/**
 * Delete a submission state from the database.
 *
 * @param int $sid
 *   The workflow state id to delete.
 */
function webform_workflow_delete_submission_state($sid) {
  return db_delete('webform_workflow_submissions')
    ->condition('sid', $sid)
    ->execute();
}

/**
 * Write submission state to the database.
 *
 * @param object $submission
 *   The webform submission.
 */
function webform_workflow_write_submission_state($submission) {
  if (isset($submission->webform_workflow_state) && !empty($submission->webform_workflow_state->wsid)) {
    db_merge('webform_workflow_submissions')
      ->key(array('sid' => $submission->sid))
      ->fields(array(
        'nid' => $submission->nid,
        'wsid' => $submission->webform_workflow_state->wsid,
      ))
      ->execute();
  }
}

/**
 * Delete a state from the database.
 *
 * @param int $wsid
 *   The workflow state id to delete.
 */
function webform_workflow_state_delete($wsid) {
  return entity_get_controller('webform_workflow_state')->delete(array($wsid));
}

/**
 * Notify users of state transition by email.
 */
function webform_workflow_notify_users($submission) {
  $state = $submission->webform_workflow_state;
  $notify_emails = webform_workflow_get_user_emails($state->data['notify_users']);

  if (!$notify_emails) {
    return;
  }

  global $user;
  $email_from = $user->mail;

  $node = node_load($submission->nid);
  $email_templates = webform_workflow_load($node)->data['emails'];

  $token_data = array(
    // @TODO: Add workflow tokens once complete.
    'node' => $node,
    'webform-submission' => $submission,
  );
  $params = array(
    'subject' => token_replace($email_templates['subject'], $token_data),
    'body'    => token_replace($email_templates['body'   ], $token_data),
  );

  foreach ($notify_emails as $email) {
    drupal_mail('webform_workflow', 'transition', $email, LANGUAGE_NONE, $params, $email_from);
  }
}

/**
 * Get array of emails from array of user uids or emails.
 */
function webform_workflow_get_user_emails($notify_users) {
  $emails = array();
  foreach ($notify_users as $u) {
    if (is_numeric($u)) {
      $user = user_load($u);
      $emails[] = $user->mail;
    }
    elseif (valid_email_address($u)) {
      $emails[] = $u;
    }
  }
  return $emails;
}

/**
 * Implements hook_mail().
 */
function webform_workflow_mail($key, &$message, $params) {
  switch($key) {
    case 'transition':
      $message['subject'] = $params['subject'];
      $message['body'][] = $params['body'];
      break;
  }
}

/**
 * Implements hook_views_api().
 */
function webform_workflow_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'webform_workflow') . '/includes',
  );
}
